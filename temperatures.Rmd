---
title: "Final project - Temperatures"
author: "Nikola Grlj"
date: "2/4/2022"
output: html_document
---

Load all necessary packages
```{r Load all packages, echo=FALSE, message=FALSE}
library (plyr)
library(tidyverse)
library(sf)
library(ggplot2)
library(stars)
library(gstat)
library(lubridate)
library(spacetime)
library(sp)
library(stringr)
library(maps)
library(rnaturalearth)
library(ggrepel)
library(RColorBrewer)
library(xts)
```

Import stations
```{r Import stations, echo=FALSE, message=FALSE}
stations <- read_csv("stations.csv")
```

Round all dates down to year
```{r Round all dates, echo=FALSE, message=FALSE}
stations$YEAR <- floor_date(stations$DATE, "year")
```

Temperature is in Fahrenheight so let's convert it to Celsius degrees
```{r Temperature conversion, echo=FALSE, message=FALSE}
stations$TEMP <- (((stations$TEMP)-32)/1.8)
```

We need to aggregate data so we get annual mean (from daily means), so we will have annual daily mean for every station for all years.
```{r Aggregate by year, echo=FALSE, message=FALSE}
agg = aggregate(stations$TEMP,list(YEAR = stations$YEAR,STATION_ID = stations$STATION,NAME = stations$NAME,LAT = stations$LATITUDE,LONG = stations$LONGITUDE,ELEVATION = stations$ELEVATION), mean)
colnames(agg)[which(names(agg) == "x")] <- "MEAN_TEMP"
agg <- agg[order(agg$YEAR), ]
agg$YEAR <- format(as.Date(agg$YEAR, format="%d/%m/%Y"),"%Y")
agg$STATION_ID <- substring(agg$STATION_ID,1,5)
```

There are 32 possible stations:
```{r Show stations, echo=FALSE, message=FALSE}
print(unique(agg$NAME))
```

Now we have issue because it seems that not every year has data for every station.
We can check that in the following way:
```{r Check for missing data, echo=FALSE, message=FALSE}
checker <- function(input_file) {
counter <- 0
full_counter <- 0
stations <- c()
my_list <- c()
differences <- c()
for (unique_year in unique(input_file$YEAR)) {
  for (year in input_file$YEAR) {
    if (unique_year == year) {
      counter = counter + 1
      full_counter = full_counter + 1
      stations[length(stations)+1] <- input_file$STATION_ID[full_counter]
    }
  }
  difference <- setdiff(unique(input_file$STATION_ID),stations)
  print(difference)
  differences[(length(differences)+1)] <- paste(unlist(difference),collapse=",")
  my_list[(length(my_list)+1)] <- counter
  counter <- 0
  stations <- c()
}
n_stations_by_year <- data.frame(YEAR = unique(input_file$YEAR),N_stations = my_list, DIFFERENCE_ID = differences)
return(n_stations_by_year)
}
checker(agg)
```

To make things coherent (I'm not sure if this is correct way) we will remove records for year 2005. and also all records for stations 14442 and 14446. Station "Portoroz" is in Slovenia so it has to be removed as well.
Let's include only data we need:
```{r Clean data, echo=FALSE, message=FALSE}
agg2 <- subset(agg, YEAR != "2005" )
agg3 <- subset(agg2, STATION_ID != "14442")
agg4 <- subset(agg3, STATION_ID != "14446")
```
Now we should have dataset without year 2005 and without station 14324. Let's check if that's correct:
```{r Check data again, echo=FALSE, message=FALSE}
checker(agg4)
```
As we can see, now all years have same stations (30 of them). Next thing we can do is create space-time object STFDF.


Create space-time object STFDF
```{r Create STFDF object, echo=FALSE, message=FALSE}
# Get station names and coordinates(LON-LAT in WGS84)
station_coords_df <- cbind(LON = agg4$LONG[1:30], LAT = agg4$LAT[1:30])
row.names(station_coords_df) <- paste(agg4$NAME[1:30])
station_coords <- SpatialPoints(station_coords_df,CRS("+init=epsg:4326"))

# Transform coordinates to projection for Croatia
station_coords <- spTransform(station_coords, CRS("+init=epsg:3765"))
# Check for duplicates. If we have duplicates, krigging won't work because we get singular covariance matrices
zerodist(station_coords)

# Time stamps
time <- as.POSIXct(unique(agg4$YEAR),tz="", "%Y")

# Temperature values
values <- agg4$MEAN_TEMP

# Create STFDF object (for static spatial instances)
df <- data.frame(values = values)
st_object <- STFDF(station_coords,time,data=df)
```

Plot STFDF data
```{r Plot STFF data, echo=FALSE, message=FALSE}
#Plot multi-panel plots, one panel for every year showing locations in the country with colors for average temperaure
stplot(st_object)

#Plot time series
stplot(st_object, mode="tp")
stplot(st_object, mode="ts")

#Plot space-time plots
scales=list(x=list(rot = 45))
stplot(st_object, mode = "xt", cuts=11,scales = scales, xlab = NULL,col.regions=rev(brewer.pal(11, "RdBu")))
```
```{r Create sample spatio-temporal variogram, echo=FALSE, message=FALSE}
sampl.var <- variogramST(values~1,data=st_object)
plot(sampl.var, map=F)
plot(sampl.var, map=T)
plot(sampl.var, wireframe=T)
```
```{r Fit variogram, echo=FALSE, message=FALSE}
# We have 5 options for fitting; separable, product sum, metric, sum metric, and simple sum metric.
# First thing is to set lower and upper limits for all models
pars.l <- c(sill.s = 0, range.s = 10, nugget.s = 0,sill.t = 0, range.t = 1, nugget.t = 0,sill.st = 0, range.st = 10, nugget.st = 0, anis = 0)
pars.u <- c(sill.s = 200, range.s = 1000, nugget.s = 100,sill.t = 200, range.t = 60, nugget.t = 100,sill.st = 200, range.st = 1000, nugget.st = 100,anis = 700) 

# Separable model for range 200km and time half a day days
separable <- vgmST("separable", space = vgm(1,"Exp", 150000, 1),time = vgm(1,"Exp",0.5 * 3600), sill=0.6)

# Check how it compares to sample variogram (doesn't pot both plots for some reason)
plot(sampl.var,separable,map=F) 
plot(sampl.var,list(separable),all=T,wireframe=T)

# Calculate fit and difference
separable_Vgm <- fit.StVariogram(sampl.var, separable, fit.method=11)
attr(separable_Vgm,"MSE")

separable_Vgm <- fit.StVariogram(sampl.var, separable, fit.method=11,method="L-BFGS-B", stAni=5, lower=pars.l,upper=pars.u)

# Product sum model

prodSumModel <- vgmST("productSum", space = vgm(1,"Exp", 150000, 1),time = vgm(1,"Exp",3600), k=50)

prodSumModel_Vgm <- fit.StVariogram(sampl.var, prodSumModel,method = "L-BFGS-B",lower=pars.l)
attr(prodSumModel_Vgm, "MSE")

# Metric
metric <- vgmST("metric", joint = vgm(50,"Mat", 5000, 0), stAni=500) 
metric_Vgm <- fit.StVariogram(sampl.var, metric, method="L-BFGS-B",lower=pars.l)
attr(metric_Vgm, "MSE")
plot(sampl.var,metric,map=F) 

# Sum metric
sumMetric <- vgmST("sumMetric", space = vgm(psill=5,"Sph", range=50000, nugget=0),time = vgm(psill=500,"Sph", range=5000, nugget=0), joint = vgm(psill=1,"Sph", range=500, nugget=10), stAni=500) 
sumMetric_Vgm <- fit.StVariogram(sampl.var, sumMetric, method="L-BFGS-B",lower=pars.l,upper=pars.u,tunit="hours")
attr(sumMetric_Vgm, "MSE")
plot(sampl.var,sumMetric,map=F) 

# Simple sum metric
SimplesumMetric <- vgmST("simpleSumMetric",space = vgm(5,"Sph", 500, 0),time = vgm(500,"Sph", 5000, 0), joint = vgm(1,"Sph", 500, 0), nugget=1, stAni=500)
SimplesumMetric_Vgm <- fit.StVariogram(sampl.var, SimplesumMetric,method = "L-BFGS-B",lower=pars.l)
attr(SimplesumMetric_Vgm, "MSE")
plot(sampl.var,SimplesumMetric,map=F) 

# Plot those which give result (only last three for now)
plot(sampl.var,list(metric_Vgm, sumMetric_Vgm, SimplesumMetric_Vgm),all=T,wireframe=T)
```



Load Croatian map
```{r Load map of Croatia, echo=FALSE, message=FALSE}
croatia_sea <- st_read("HRV_adm/croatia.geojson")
croatia_land <- st_read("HRV_adm/croatia_land.geojson")
single_sf <- bind_rows(list(croatia_sea,croatia_land))
```

Create map for Croatia together with stations.
```{r Croatia map, fig.align='center',fig.width=10, fig.height=7, include=TRUE, results='hide'}
stations_only <- data.frame(LON = agg4$LONG[1:30], LAT = agg4$LAT[1:30])
NAME <- c(agg4$NAME[1:30])
stations_only <- cbind(stations_only,NAME)
plot_with_points <- ggplot() +
  geom_sf(data = single_sf) +
  geom_point(data = stations_only,
             mapping = aes(x = LON, y = LAT),
             colour = "red",
             size = 6,
             shape = 4) +
  coord_sf()

plot_with_points + 
  geom_label_repel(data = stations_only, aes(x = LON, y = LAT,label = NAME),
                  box.padding   = 0.35, 
                  point.padding = 0.5,
                  segment.color = 'grey50') +
  theme_classic()
```
For some reason, grid is created for rectangle and for Croatian boundaries. There are different values inside grid cells depending one the position of cell. I will assign NA value to cells outside Croatian boundary, and value 0 to cells inside Croatia.
```{r Create grid, echo=FALSE, message=FALSE}
croatia_grid_sf <- st_read("Croatia_shapefile/hr_10km.shp")
croatia_grid_sf <- st_transform(croatia_grid_sf,3765)
croatia_bbox <- st_as_sfc(st_bbox(croatia_grid_sf))
croatia_outer_border <- st_intersection(croatia_bbox,croatia_grid_sf)
croatia_grid_stars <- st_as_stars(croatia_outer_border, dx = 10000)

#replace bin values
for (x in 1:54) {
  for (y in 1:57) {
    if (croatia_grid_stars[[1]][x:x,y:y] == 0) {
      croatia_grid_stars[[1]][x:x,y:y] <- NA
    } 
    else {
      croatia_grid_stars[[1]][x:x,y:y] <- 0
    }
  }
}
```
Try process data along the logic of Irish wind example, so for a start, I will create space-wide form of data so I can follow the steps of tutorial.
```{r, echo=FALSE, message=FALSE}
# Create temp.loc object which hold station names, IDs, and coordinates
temp.loc <- data.frame(NAME=agg4$NAME[1:30],ID=agg4$STATION_ID[1:30],LON=agg4$LONG[1:30],LAT=agg4$LAT[1:30])
# Convert to spatial object
coordinates(temp.loc) = ~LON+LAT
# Set projection and datum
proj4string(temp.loc) = "+proj=longlat +datum=WGS84"
# Make transformed table
station.names <- unique(agg4$NAME)
stations.temps <- data.frame(NAME=agg4$NAME,TEMP=agg4$MEAN_TEMP)
counter <- 1

for (station in station.names) {
  if (counter == 1) { 
  current.subset <- subset(stations.temps, NAME == station)
  holder <- data.frame(current.subset$TEMP)
  colnames(holder)[ncol(holder)] <- paste0(station)
  counter = counter + 1
  }
  else {
  current.subset <- subset(stations.temps, NAME == station)
  holder[,ncol(holder)+1] <- current.subset$TEMP
  colnames(holder)[ncol(holder)] <- paste0(station)
  counter = counter + 1
  }
}
# Convert year to ISO year
holder$YEAR <- ISOdate(unique(agg4$YEAR),12,31)

# Remove means from temperature values
enum_stations <- 1:30
detrended <- as.matrix(holder[enum_stations]) - mean(as.matrix((holder[enum_stations])))

# Create spatio-temporal object
temp.data <- stConstruct(detrended,space = list(values = 1:ncol(detrended)), time = holder$YEAR, SpatialObj =  station_coords, interval = TRUE)

# Pull map of Croatia
map.cro = map2SpatialLines(map("world", xlim = c(14,20), ylim = c(43,46), plot=F))
proj4string(map.cro) = "+init=epsg:3765"
map.cro = spTransform(map.cro, utm33)

# Create spatio-temporal grid for 10 points in period from 2004-2020
spatial.grid = SpatialPixels(SpatialPoints(makegrid(map.cro, n = 10000)),proj4string = proj4string(map.cro))

tgrd = seq(min(index(temp.data)), max(index(temp.data)), length=16)
pred.grd = STF(spatial.grid, tgrd)

v = vgmST("separable", space = vgm(1, "Exp", 750000), time = vgm(1, "Exp", 1.5 * 3600),sill=0.6)
v = variogramST(values~1,data=st_object)

temp.ST = krigeST(values ~ 1, temp.data, pred.grd, v)
```
